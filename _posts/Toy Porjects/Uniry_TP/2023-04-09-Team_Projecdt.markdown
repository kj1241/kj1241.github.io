---
layout: post
title:  "유니티 팀 프로젝트 수업 과제 및 결과물"
date:   2023-04-09 17:36:45 +0900
image: https://drive.google.com/uc?export=view&id=16DtnUKQaymL0m38oQwHf2yjGV4f5zONB
toc: true
categories: [Unity_TP]
tags: [C#, Unity, Shader]
---

## <green1_h2> 팀 프로젝트 소개 </green1_h2>

첫 팀프로젝트로 개발한 유니티 C# 게임은 간단한 버튼 클릭 기반의 게임입니다.  
플레이어는 다양한 버튼을 활용하여 게임 내 도전과 퍼즐을 해결하며, 간단하면서도 재미있는 게임 경험을 제공합니다.  
게임은 초보자에게 프로그래밍 및 게임 디자인의 기초를 익히기에 이상적입니다.  

<br>
<br>

## <green1_h2> 팀 프로젝트 개요 </green1_h2>

- <span><green1_h5>프로젝트명: </green1_h5> the Untitled Kingdom</span>
- <span><green1_h5>장르: </green1_h5> 2016년 1학기 팀 프로젝트 최종 과제</span>
- <span><green1_h5>게임 장르: </green1_h5> 2D Platformer Game</span>
- <span><green1_h5>기간: </green1_h5> 22016.03.15~2016.05.31(제작) / 2023.04.07~2023.04.08(엔진 업데이트)</span>
- <span><green1_h5>플랫폼: </green1_h5> PC (Window)</span> 

<br>
<br>

## <green1_h2> 팀 프로젝트 팀 구성 </green1_h2>

- <span><yellow1_h5>Prgrammer(1명): </yellow1_h5> 게임 로직 설계, 게임 구성, 연출 구성, 파티클 보조, 쉐이더제작, UI 제작</span>
- <span><yellow1_h5>Artist(3명): </yellow1_h5> World Creator를 통한 지형제작, UI 디자인, 폰트디자인, 원화, 에프트이펙트를 통한 이펙트디자인</span>
- <span><yellow1_h5>Game Designer(1명): </yellow1_h5> 게임 스크립트 제작, 시나리오 제작, 오디오 사운드 제작</span>

<br>
<br>

## <green1_h2> 팀 프로젝트 기술 스택 </green1_h2>

- <span><green1_h5>엔진: </green1_h5> Unity 5.3.6.f1 → 2019.4.22f1  </span>
- <span><green1_h5>언어: </green1_h5> C# / mono </span>
- <span><green1_h5>그래픽 디자인: </green1_h5>>Adobe Photoshop / Adobe Illustrator / World Creator </span>
- <span><green1_h5>음향 효과: </green1_h5>Adobe Audiition </span>

<br>
<br>

## <green1_h2> 팀 프로젝트 특징 </green1_h2>

1. 그래픽 학과 아티스트와 협업하여 프로젝트를 제작하였습니다.
2. 버튼형 게임으로 포켓몬스터에서 영감을 받았습니다.

<br>
<br>

## <green1_h2> 팀 프로젝트의 개발자의 역활 및 경험 </green1_h2>

- **팀 프로젝트 버튼형 게임 제작** <span><red1_error>(전체 게임 제작 기여도: 35%)</red1_error></span>
    1. 영화적 효과 연출을 위한 필름 효과 쉐이더 제작 (인트로 화면).
    2. 불타는 효과 제작(인트로 화면).
    3. GPU Gems라는 책을 읽고 부서지는 오크통에 영감을 받아 부셔지는 화면 제작(인트로 화면).
    4. Silder를 이용한 HP 바 제작(게임 화면).
    5. 폭발하는 파티클 제작(게임 화면).
    6. 게임 로직 코드 작성 및 UI 제작.
    7. 스킬 쿨타임 구현.
    8. 게임 일시정지 효과를 이용한 시작 전 일시정지 구현.
    9. 펀치 머싱을 이용한 공격스킬 UI 효과 제작.
    10. 로그 화면을 만들어서 실시간 에러확인.

<br>

### <green1_h3> 엔진 업데이트 전 </green1_h3>

![엔진업데이트 전](https://drive.google.com/uc?export=view&id=1lijTJu5q_ZTjjdoDT-AEvIZoFo6-RC70){: width="100%" style="aspect-ratio:16/9"}

<br>

### <green1_h3> 엔진 업데이트 후 </green1_h3>

![엔진업데이트 후](https://drive.google.com/uc?export=view&id=1N0c23zASRzrgoHOo4qBkpI81_EQ2HWsH){: width="100%" style="aspect-ratio:16/9"}

<br>
<br>

## <green1_h2> 팀 프로젝트 결과(성과) 및 데모 </green1_h2>

- <span><green1_h5>성과: </green1_h5> 2016년 1학기 팀 프로젝트 최종 과제 </span>
- <span><green1_h5>지드라이브(코드): </green1_h5> [https://drive.google.com/drive/folders/1i84Sc-GpJ3PSuZGPUxoNb8lWFGAFlICW?usp=share_link](https://drive.google.com/drive/folders/1i84Sc-GpJ3PSuZGPUxoNb8lWFGAFlICW?usp=share_link)</span> 
- <green1_h5>유튜브 동영상: </green1_h5> 
    <iframe width="100%" style="aspect-ratio:16/9" src="https://www.youtube.com/embed/OY4DGZKvkF8" title="팀 프로젝트(the_Untitled_Kingdom)" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" allowfullscreen></iframe>

<br>

### <green1_h3> 배운 점 및 앞으로 수정할 점 </green1_h3>

- 배운점
    - UI로직을 구현하고 HP, 쿨타임을 구현할 수 있게 되었습니다.
    - TimeSacle과 상태 스테이트 패턴을 이용하여 게임 일시정지를 구현할 수 있게 되었습니다.
    - 파티클을 이용하여 공격과 힐 스킬을 구현 할 수 있게 되었습니다.
    - 카메라 특수효과인 필름 효과와 물 효과 쉐이더를 제작할 수 있게 되었습니다.
    - 포토샵을 이용하여 필요한 리소스를 생성할 수 있게 되었습니다.
    - 로그 화면을 이용하여 에러 확인 및 게임 진행 상황을 이해할 수 있게 되었습니다.

- 수정할 점
    - 제작 당시 리더십이 부족해서 프로젝트를 좀 더 완성도 있게 제작하지 못했습니다.
    - 무조건 코드를 사용하여 제작해서 완성시켜야 한다는 생각 때문에 에셋을 사용하지 않았습니다.

<br>

---
---

<br>

## <green1_h2> 팀 프로젝트 과제 소개 </green1_h2>

대학교 시절 팀 프로젝트 학과 과제 모음입니다.  
당시, 처음 유니티를 접했기 때문에 프로젝트를 완성하기 위해서 필요한 부분을 자율적으로 공부 및 코드를 작성하여 발표했던 내용입니다.  
코드가 세련되지 않아도 양해해 주시면 감사하겠습니다.  

<br>
<br>

## <green1_h2> 팀 프로젝트 과제 개요 </green1_h2>

- <span><green1_h5>프로젝트명: </green1_h5> 팀프로젝트 과제</span>
- <span><green1_h5>장르: </green1_h5> 2016년 1학기 팀 프로젝트 과제</span>
- <span><green1_h5>기간: </green1_h5> 22016.03.15~2016.05.31</span>
- <span><green1_h5>플랫폼: </green1_h5> PC (Window)</span> 

<br>
<br>

## <green1_h2> 팀 프로젝트 과제 팀 구성 </green1_h2>

- <span><yellow1_h5>Prgrammer(1명): </yellow1_h5>각종 유니티 프로그래밍 코드 연습 </span>

<br>
<br>

## <green1_h2> 팀 프로젝트 과제 기술 스택 </green1_h2>

- <span><green1_h5>엔진: </green1_h5> Unity 5.3.6.f1 → 2019.4.22f1  </span>
- <span><green1_h5>언어: </green1_h5> C# / mono </span>
- <span><green1_h5>그래픽 디자인: </green1_h5>>Adobe Photoshop </span>

<br>
<br>

## <green1_h2> 팀 프로젝트 과제 개발자의 역활 및 경험 </green1_h2>

- **프로젝트를 위한 게임 실습 과제** <span><red1_error>(전체 게임 제작 기여도: 100%)

<br>

### <green1_h3> 모작) 카메라 프로세싱 쉐이더 제작 </green1_h3>

- FPS를 제작 준비를 하기위해 위해서 포스트 프로세싱을 사용하기로 결정.
- 카메라에 쉐이더 효과를 부여해서 나이트 비전 제작.

    ![나이트비전](https://drive.google.com/uc?export=view&id=1C-aUoVIB7C7doYFUnOjISRAboZ3j3m8U){: width="100%" }

    <details markdown=1>
    <summary> 나이트 비전 쉐이더 코드 </summary>

    ```hlsl

    Shader "Custom/NightVisionEffectShader" 
    {
        //속성창
        Properties 
        {
            _MainTex ("Base (RGB)", 2D) = "white" {}
            _VignetteTex ("Vignette Texture", 2D) = "white"{}
            _ScanLineTex ("Scan Line Texture", 2D) = "white"{}
            _NoiseTex ("Noise Texture", 2D) = "white"{}
            _NoiseXSpeed ("Noise X Speed", Float) = 100.0
            _NoiseYSpeed ("Noise Y Speed", Float) = 100.0
            _ScanLineTileAmount ("Scan Line Tile Amount", Float) = 4.0
            _NightVisionColor ("Night Vision Color", Color) = (1,1,1,1)
            _Contrast ("Contrast", Range(0,4)) = 2
            _Brightness ("Brightness", Range(0,2)) = 1
            _RandomValue ("Random Value", Float) = 0
            _distortion ("Distortion", Float) = 0.2
            _scale ("Scale (Zoom)", Float) = 0.8
        }
        
        SubShader 
        {
            Pass
            {
                CGPROGRAM
                #pragma vertex vert_img
                #pragma fragment frag
                #pragma fragmentoption ARB_precision_hint_fastest
                #include "UnityCG.cginc"
                
                uniform sampler2D _MainTex;
                uniform sampler2D _VignetteTex;
                uniform sampler2D _ScanLineTex;
                uniform sampler2D _NoiseTex;
                fixed4 _NightVisionColor;
                fixed _Contrast;
                fixed _ScanLineTileAmount;
                fixed _Brightness;
                fixed _RandomValue;
                fixed _NoiseXSpeed;
                fixed _NoiseYSpeed;
                fixed _distortion;
                fixed _scale;
                
                float2 barrelDistortion(float2 coord) 
                {
                    // 랜즈 왜곡 알고리즘 참조: http://www.ssontech.com/content/lensalg.htm
                    float2 h = coord.xy - float2(0.5, 0.5);
                    float r2 = h.x * h.x + h.y * h.y;
                    float f = 1.0 + r2 * (_distortion * sqrt(r2));

                    return f * _scale * h + 0.5;
                }
                
                //알파값을 가질수 없음
                fixed4 frag(v2f_img i) : COLOR
                {
                    //랜더 텍스처의 uv 색상 가저오기
                    half2 distortedUV = barrelDistortion(i.uv); //베럴 왜곡(블록렌즈)
                    fixed4 renderTex = tex2D(_MainTex, distortedUV);//메인텍스처 입히기
                    fixed4 vignetteTex = tex2D(_VignetteTex, i.uv);//줌 모드 텍스쳐 가져오기
                    
                    //스캔 라인 노이즈 처리
                    half2 scanLinesUV = half2(i.uv.x * _ScanLineTileAmount, i.uv.y * _ScanLineTileAmount);//UV 값에  _ScanLineTileAmount 곱하기
                    fixed4 scanLineTex = tex2D(_ScanLineTex, scanLinesUV);// 매칭
                
                    
                    // _SinTime.x == Sin(t/8),  _SinTime.y == Sin(t/4),  _SinTime.z == Sin(t/2), _SinTime.w == Sin(t)
                    //시간 단위의 사인 함수 그래프(시간도 차원임으로)
                    half2 noiseUV = half2(i.uv.x + (_RandomValue * _SinTime.z * _NoiseXSpeed), i.uv.y + (_Time.x * _NoiseYSpeed));
                    fixed4 noiseTex = tex2D(_NoiseTex, noiseUV); //적용
                    
                    //아날로그 컬러 TV에 사용되는 색을 사용하기 위에 rgb -> YIQ 변환에서 Y 끌어다 오기
                    fixed lum = dot (fixed3(0.299, 0.587, 0.0114), renderTex.rgb); // rgb -> Y
                    lum += _Brightness; //광도 더해주기
                    fixed4 finalColor = (lum *2) + _NightVisionColor; //비전색상값 더하기

                    //출력
                    finalColor = pow(finalColor, _Contrast); //finalColor^ _Contrast
                    finalColor *= vignetteTex; //줌 모드 텍스쳐
                    finalColor *= scanLineTex * noiseTex; //노이즈
                    finalColor.a = finalColor.r;
                    
                    return finalColor;
                }
        
                ENDCG
            }
        } 
        FallBack off
    }
    
    ```

    </details>

<br>

### <green1_h3> 모작) 오래된 필름 효과 쉐이더 제작 </green1_h3>

- 인트로 화면 제작 준비를 하기위해 위해서 포스트 프로세싱을 사용하기로 결정.
- 카메라에 쉐이더 효과를 부여해서 오래된 필름 효과 제작.    

    ![오래된 필름](https://drive.google.com/uc?export=view&id=1WSMPcV5OsFBC-sKsuwBlSnQjtKBgZUip){: width="100%" }

    <details markdown=1>
    <summary> 오래된 필름 효과 쉐이더 </summary>

    ```hlsl

    Shader "Custom/OldFilmEffectShader"
    {
        Properties 
        {
            _MainTex ("Base (RGB)", 2D) = "white" {}
            _VignetteTex ("Vignette Texture", 2D) = "white"{}
            _ScratchesTex ("Scartches Texture", 2D) = "white"{}
            _DustTex ("Dust Texture", 2D) = "white"{}
            _SepiaColor ("Sepia Color", Color) = (1,1,1,1)
            _EffectAmount ("Old Film Effect Amount", Range(0,1)) = 1.0
            _VignetteAmount ("Vignette Opacity", Range(0,1)) = 1.0
            _ScratchesYSpeed ("Scratches Y Speed", Float) = 10.0
            _ScratchesXSpeed ("Scratches X Speed", Float) = 10.0
            _dustXSpeed ("Dust X Speed", Float) = 10.0
            _dustYSpeed ("Dust Y Speed", Float) = 10.0
            _RandomValue ("Random Value", Float) = 1.0
            _Contrast ("Contrast", Float) = 3.0
            
            _distortion ("Distortion", Float) = 0.2
            _cubicDistortion ("Cubic Distortion", Float) = 0.6
            _scale ("Scale (Zoom)", Float) = 0.8
        }
        
        SubShader 
        {
            Pass
            {
                CGPROGRAM
                #pragma vertex vert_img
                #pragma fragment frag
                #pragma fragmentoption ARB_precision_hint_fastest
                #include "UnityCG.cginc"
                
                uniform sampler2D _MainTex;
                uniform sampler2D _VignetteTex;
                uniform sampler2D _ScratchesTex;
                uniform sampler2D _DustTex;
                fixed4 _SepiaColor;
                fixed _VignetteAmount;
                fixed _ScratchesYSpeed;
                fixed _ScratchesXSpeed;
                fixed _dustXSpeed;
                fixed _dustYSpeed;
                fixed _EffectAmount;
                fixed _RandomValue;
                fixed _Contrast;
                
                float _distortion;
                float _cubicDistortion;
                float _scale;

                float2 barrelDistortion(float2 coord) 
                {
                    // 랜즈 왜곡 알고리즘 참조: http://www.ssontech.com/content/lensalg.htm
                    float2 h = coord.xy - float2(0.5, 0.5);
                    float r2 = h.x * h.x + h.y * h.y;
                    float f = 1.0 + r2 * (_distortion + _cubicDistortion * sqrt(r2));

                    return f * _scale * h + 0.5;
                }

                //알파값을 가질수 없음
                fixed4 frag(v2f_img i) : COLOR
                {
                    //랜더 텍스처의 uv 색상 가저오기
                    //half2 distortedUV = barrelDistortion(i.uv); //베럴 왜곡(블록렌즈)
                    //half2 waveYUV = half2(i.uv.x, i.uv.y + (_RandomValue * _SinTime.z * 0.003));//사인 함수로 y축 흔들기
                    fixed4 renderTex = tex2D(_MainTex, i.uv); //메인텍스쳐
                    
                    //비네팅 광학사진 주변 텍스쳐 가저오기
                    fixed4 vignetteTex = tex2D(_VignetteTex, i.uv);
                    
                    //스크레치의 픽셀처리
                    half2 scratchesUV = half2(i.uv.x + (_RandomValue * _SinTime.z * _ScratchesXSpeed), i.uv.y + (_Time.x * _ScratchesYSpeed)); //x축은 사인함수로 y는 위로
                    fixed4 scratchesTex = tex2D(_ScratchesTex, scratchesUV);
                    
                    //먼지처리
                    half2 dustUV = half2(i.uv.x + (_RandomValue * (_SinTime.z * _dustXSpeed)),i.uv.y + (_RandomValue * (_SinTime.z * _dustYSpeed)));
                    fixed4 dustTex = tex2D(_DustTex, dustUV);
                
                    fixed lum = dot (fixed3(0.299, 0.587, 0.0114), renderTex.rgb); //rgb -> Y

                    
                    fixed4 finalColor = lum + lerp(_SepiaColor, _SepiaColor + fixed4(0.01f,0.01f,0.01f,1.0f), _RandomValue);  //배경 색상 추가
                    finalColor = pow(finalColor, _Contrast); //finalColor^ _Contrast
                    
                    fixed3 blandingWhite = fixed3(1,1,1); //색을 흔들기 위해서
                    
                    //출력
                    finalColor = lerp(finalColor, finalColor * vignetteTex, _VignetteAmount);
                    finalColor.rgb *= lerp(scratchesTex, blandingWhite, (_RandomValue));
                    finalColor.rgb *= lerp(dustTex.rgb, blandingWhite, (_RandomValue * _SinTime.z));
                    finalColor = lerp(renderTex, finalColor, _EffectAmount);
                    
                    return finalColor;
                }
        
                ENDCG
            }
        } 
        FallBack off
    }
    
    ```

    </details>

<br>

### <green1_h3> 모작) 파이어볼 스킬 제작 </green1_h3>

- 펄린 노이즈 난수를 이용한 생성돔 생성
- 콜라이더 충돌처리 
- 시간 파이프라인을 제작하여 스킬의 선 딜레이, 후 딜레이 제작
- 프렉탈 패턴을 이용한 쉐이더 FX를 이용한 파이어볼 제작(파티클 시스템 X)
- 후속 폭발 효과 적용

1. 코드를 이용한 라이트 처리
    
    ![펄린 노이즈](https://drive.google.com/uc?export=view&id=1KURjFZPvoSVZD_7hTVj1Gv9ICNaXF_lA){: width="100%" }
        
    <details markdown =1>
    <summary> 펄린노이즈 C# 코드 </summary>

    ```c#

    //펄린 노이즈(구름등 난수 생성)
    float timeAcceleration = 1.5f;
    float x = Mathf.PerlinNoise(seed + 0 + Time.time * timeAcceleration, seed + 1 + Time.time * timeAcceleration) - 0.5f; //0,1번
    float y = /*firePointLightY +*/ Mathf.PerlinNoise(seed + 2 + Time.time * timeAcceleration, seed + 3 + Time.time * timeAcceleration) - 0.5f; //2,3번
    float z = Mathf.PerlinNoise(seed + 4 + Time.time * timeAcceleration, seed + 5 + Time.time * timeAcceleration) - 0.5f; //4 ,5 번
    firePointLight.gameObject.transform.localPosition = Vector3.up + new Vector3(x, y, z);

    ```

    </details>  


2. 스킬 쉐이더 쉐이더 제작 및 physic를 이용한 충돌 처리 
    
    ![충돌 처리](https://drive.google.com/uc?export=view&id=1Elp_oxSDPyCYybYU5PIykMuMCQEizWJH){: width="100%" }
    
    <details markdown =1>
    <summary> 콜라이더 핸들러 인터페이스 C# 코드 </summary>

    ```c#

    namespace FireBall
    {
        //콜라이더 핸들러 인터페이스
        public interface ICollisionHandler
        {        
            void HandleCollision(GameObject obj, Collision c);
        }

        public class FireBallCollder : MonoBehaviour
        {
            public ICollisionHandler CollisionHandler; //인터페이스

            public void OnCollisionEnter(Collision col) //충돌트리거에 들어갔을대 알려줌
            {
                CollisionHandler.HandleCollision(gameObject, col);
            }
            // Start is called before the first frame update
            void Start()
            {

            }

            // Update is called once per frame
            void Update()
            {

            }
        }
    }

    ```

    </details>
    
    <br>

    ![최적화를 위한 파티클 시스템 및 빌보드](https://drive.google.com/uc?export=view&id=1SUiNA5qeaFPOjBtoqy4178KUxoMqI9p9){: width="100%" }
    *최적화를 위한 파티클 시스템 및 빌보드*

    ![파티클 시스템을 이용한 파이어 볼](https://drive.google.com/uc?export=view&id=1xdVE23RckX7nrYUXPOhNa2N6EOoqfhsR){: width="100%" }
    *파티클 시스템을 이용한 파이어 볼*    

    <details markdown =1>
    <summary> SkillScript C# 코드 </summary>

    ```c#

    namespace FireBall
    {

        [System.Serializable]
        public struct RangeOfIntegers
        {
            public int Minimum;
            public int Maximum;
        }

        [System.Serializable]
        public struct RangeOfFloats
        {
            public float Minimum;
            public float Maximum;
        }

        public enum SkillStatePipLine
        {
            error = -1,
            start = 0,
            play = 1,
            end = 2
        }

        public class SkillScript : MonoBehaviour
        {

            [Tooltip("선 딜레이")]
            public float StartTime = 1.0f;

            [Tooltip("후 딜레이")]
            public float StopTime = 3.0f;

            [Tooltip("총 에니메이션 시간")]
            public float Duration = 2.0f;

            [Tooltip("폭발에서 생성할 힘의 크기")]
            public float ForceAmount;

            [Tooltip("힘의 반지름")]
            public float ForceRadius;

            [Tooltip("개체가 투사체")]
            public bool IsProjectile;

            [Tooltip("수동으로 시작해야되며 재생되지 않는 파티클 시스템")]
            public ParticleSystem[] ManualParticleSystems;

            private float startTimeMultiplier; //시작 시간 계수
            private float startTimeCurrent=0.0f; // 시작까지 걸리는 현재 시간 = 선딜레이

            private float stopTimeMultiplier; //정지 시간 계수
            private float stopTimeCurrent=0.0f; // 정지까지 걸리는 현재 시간 = 후딜레이

            public SkillStatePipLine SkillState
            {
                get;
                set;
            }
            public float StartCurrenDelayTime
            {
                get;
                private set;
            }

            public float StopCurrenDelayTime
            {
                get;
                private set;
            }


            protected virtual void Awake()
            {
                SkillState = SkillStatePipLine.start; //시작
                //Starting = true; //시작했는가?
                int fireLayer = UnityEngine.LayerMask.NameToLayer("FireLayer");
            }

            // Start is called before the first frame update
            protected virtual void Start()
            {
                // 프레임에 대해서 사용하기 위해서 계수를 미리 제작
                stopTimeMultiplier = 1.0f / StopTime; //계수
                startTimeMultiplier = 1.0f / StartTime; //계수

                // 이효과가 폭발하면 적용
                CreateExplosion(gameObject.transform.position, ForceRadius, ForceAmount);

                // 파티클 시스템 시작
                StartParticleSystems();

                //콜라이더 핸들 인터페이스에 전달
                //충돌 이벤트연결
                ICollisionHandler handler = (this as ICollisionHandler); //충돌핸들 인터페이스가져오고
                if (handler != null) //충돌 핸들 인터페이스가 존재한다면
                {
                    FireBallCollder collision = GetComponentInChildren<FireBallCollder>();
                    if (collision != null)
                    {
                        collision.CollisionHandler = handler; //자식 오브젝트에 인터페이스 연동
                    }
                }

            }

            // 프레임에 따른 시간으로 관리함
            protected virtual void Update()
            {
                Duration -= Time.deltaTime; // 총 에니메이션 시간
                if (SkillState==SkillStatePipLine.end) //정지라면
                {
                    stopTimeCurrent += Time.deltaTime; //후 딜레이를 향해 간다.
                    if (stopTimeCurrent < StopTime) //후 딜레이가 아니라면
                    {
                        StopCurrenDelayTime = stopTimeCurrent * stopTimeMultiplier; //계수를 곱해서 알려줌
                    }
                }
                else if (SkillState==SkillStatePipLine.start) // 스킬 상태가 진행중이라면
                {
                    startTimeCurrent += Time.deltaTime;
                    if (startTimeCurrent < StartTime) //선 딜레이 시간 안됬으면 
                    {
                        StartCurrenDelayTime = startTimeCurrent * startTimeMultiplier; 
                    }
                    else
                    {
                        SkillState = SkillStatePipLine.play; //플레이 상태로 변환
                    }
                }
                else if (Duration <= 0.0f) //지속시간이 다됬다면 
                {
                    Stop();//정지
                }
            }


            private IEnumerator CleanupEverything()
            {
                // 에니메이션과 그래픽이 확인되기 위해서 2초 추가
                yield return new WaitForSeconds(StopTime + 2.0f);
                GameObject.Destroy(gameObject); // 제거
            }

            //파티클 시스템 시작
            private void StartParticleSystems()
            {
                //파티클 시스템 찾기(자식오브젝트에 있는)
                foreach (ParticleSystem p in gameObject.GetComponentsInChildren<ParticleSystem>())
                {
                    if (ManualParticleSystems == null || ManualParticleSystems.Length == 0 || System.Array.IndexOf(ManualParticleSystems, p) < 0)
                    {
                        if (p.startDelay == 0.0f)
                        {
                            //변경될 수 있음으로 다음프레이까지 대기
                            p.startDelay = 0.01f;
                        }
                        p.Play(); //파티클 시스템 시작하기
                    }
                }
            }

            //폭발 생성 위치 반경 힘
            public static void CreateExplosion(Vector3 pos, float radius, float force)
            {
                if (force <= 0.0f || radius <= 0.0f) //힘과 반경이 0보다 작으면 리턴
                {
                    return;
                }

                // 주변에 있는 콜라이더를 추출하여 가져오기 (몬스터를 때리면 주변에 있는 몬스터들도 찾아올수 있음)
                Collider[] objects = UnityEngine.Physics.OverlapSphere(pos, radius);
                foreach (Collider h in objects) //모든 콜라이더에게 적용시킴
                {
                    Rigidbody r = h.GetComponent<Rigidbody>(); //리지드 바디를 얻어오고
                    if (r != null)
                    {
                        r.AddExplosionForce(force, pos, radius); //백터반경의 힘을 추가한다.
                    }
                }
            }

            public virtual void Stop()
            {
                if (SkillState == SkillStatePipLine.end) //이미 중지단계라면 여기 들어오면 안되니 리턴
                {
                    return;
                }
                SkillState = SkillStatePipLine.end; //중지 단계로 만들기

                //파티클 시스템 정리 (중지단계 한번만 사용됨으로 괜찮음)
                foreach (ParticleSystem p in gameObject.GetComponentsInChildren<ParticleSystem>())
                {
                    p.Stop();
                }

                StartCoroutine(CleanupEverything()); //지운다.
            }

        
        }
    }

    ```

    </details>

    <details markdown =1>
    <summary> FireBallSystem C# 코드 </summary>

    ```c#

    namespace FireBall
    {
        public delegate void FireProjectileCollisionDelegate(FireBallSystem script, Vector3 pos); //파이어볼 콜라이더 델리게이트
    
        public class FireBallSystem : SkillScript, ICollisionHandler
        {

            [Header("FireBallSystem")]
            [Tooltip("충돌 및 물리에 사용될 개체")]
            public GameObject ColliderObject;

            [Tooltip("충돌시 재생하는 파티클 시스템")]
            public ParticleSystem ExplosionParticleSystem;

            [Tooltip("충돌시 폭발 반경")]
            public float ExplosionRadius = 0.0f;

            [Tooltip("충돌시 폭발하는 힘")]
            public float ExplosionForce = 0.0f;

            [Tooltip("사전에 시전 에니메이션이 있을겨우 전송 지연")]
            public float ColliderDelay = 0.0f;

            [Tooltip("충돌의 속도")]
            public float ColliderSpeed = 0.0f;

            [Tooltip("콜라이더의 진행 방향")]
            public Vector3 Direction = Vector3.forward;

            [Tooltip("콜라이더가 충돌 할 수 있는 레이어")]
            public LayerMask CollisionLayers = Physics.AllLayers;

            [Tooltip("충돌시 파괴되는 파티클 시스템")]
            public ParticleSystem[] DestroyParticleSystemsOnCollision;

            [HideInInspector]
            public FireProjectileCollisionDelegate CollisionDelegate; //델리게이트

            private bool collided=false;

            private IEnumerator PhysicsTransform() //방향 각도 
            {
                yield return new WaitForSeconds(ColliderDelay); //지연시간 후에 시작

                Vector3 dir = Direction * ColliderSpeed; //방향
                dir = ColliderObject.transform.rotation * dir;
                ColliderObject.GetComponent<Rigidbody>().velocity = dir; //한번뿐이니 괜찮음
            }

            // Start is called before the first frame update
            protected override void Start()
            {
                base.Start();
                StartCoroutine(PhysicsTransform()); //콜라이더 이후 딜레이
            }

            public void HandleCollision(GameObject obj, Collision c) //인터페이스 상속받은 콜라이더 충돌시
            {
                if (collided) //충돌중이라면
                {
                    return; //충돌 리턴
                }

                collided = true;
                Stop(); //멈추고

                // 파티클 시스템 파괴
                if (DestroyParticleSystemsOnCollision != null)
                {
                    foreach (ParticleSystem p in DestroyParticleSystemsOnCollision)
                    {
                        GameObject.Destroy(p, 0.01f);// 파티클 제거
                    }
                }

                if (ExplosionParticleSystem && ExplosionParticleSystem.gameObject.activeSelf != false && c.contacts.Length != 0)
                {
                    ExplosionParticleSystem.transform.position = c.contacts[0].point;
                    ExplosionParticleSystem.Play();
                    SkillScript.CreateExplosion(c.contacts[0].point, ExplosionRadius, ExplosionForce); //폭발
                    if (CollisionDelegate != null) //델리게이트가 있다면
                    {
                        CollisionDelegate(this, c.contacts[0].point); //전달
                    }
                }
            }
        }
    }

    ```

    </details>
    
    <br>

    ![프렉탈 패턴](https://drive.google.com/uc?export=view&id=1aa4IR0lYiWufqqEmy7L0Dm8KfTzb4w4X){: width="100%" }

   
    <details markdown =1>
    <summary> 프렉탈 패턴 shader 코드 </summary>

    ```hlsl

    Shader "Custom/FractalFireBall"
    {
        Properties
        {
            _MainTex("Ramp", Rect) = "white"
            _NoiseTex("Noise", 2D) = "grey"
            _Heat("Heat", Float) = 1
            _Radius("Radius", Float) = 1
            _Frequency("Noise Frequency", Float) = 1
            _ScrollSpeed("Noise Scroll Speed", Float) = 1
            _Alpha("Alpha", Float) = 1
        }
        SubShader
        {
            Tags {"Queue" = "Transparent" "RenderType" = "Transparent" "IgnoreProjector" = "True"} //IgnoreProjector프로젝터에 영향을 주지 않음
            LOD 1000

            Pass {
                ColorMask 0
                ZWrite On
                CGPROGRAM
                #pragma target 3.0
                #pragma glsl
                #pragma vertex vert
                #pragma fragment frag
                #include "UnityCG.cginc"

                struct v2f
                {
                    float4 vertex : SV_POSITION;
                };

                v2f vert(appdata_base v)
                {
                    v2f o;
                    o.vertex = UnityObjectToClipPos(v.vertex - float4(v.normal * .25, 0)); //로컬좌표를 투영좌표로
                    return o;
                }

                half4 frag(v2f i) : COLOR
                {
                    return half4(1, 1, 1, 1);
                }

                ENDCG
            }

            Pass
                {
                Blend SrcAlpha OneMinusSrcAlpha //알파블랭딩 1-alpha
                CGPROGRAM
                #pragma vertex vert
                #pragma fragment frag
                #pragma target 3.0
                #pragma glsl
                    //#pragma exclude_renderers d3d11_9x	
                    #include "UnityCG.cginc"

                    #pragma multi_compile QUALITY_HIGH QUALITY_LOW QUALITY_MED
                    #pragma multi_compile OCTAVES_1 OCTAVES_2 OCTAVES_3 OCTAVES_4 OCTAVES_5 //순서는 ... 고민
                    #pragma multi_compile SCATTERING_ON SCATTERING_OFF

                #if QUALITY_LOW //품질이 낮다면
                    #define THRESHOLD .15
                    #define PRIMARY 9
                    #define SECONDARY 5
                    #define HEATSTEP .2
                #elif QUALITY_MED
                    #define THRESHOLD .05
                    #define PRIMARY 15
                    #define SECONDARY 8
                    #define HEATSTEP .15
                #elif QUALITY_HIGH
                    #define THRESHOLD .02
                    #define PRIMARY 25
                    #define SECONDARY 10
                    #define HEATSTEP .1
                #endif
                    sampler2D _MainTex;
                    sampler2D _NoiseTex;
                    float _Heat;
                    float _Radius;
                    float _Frequency;
                    float _ScrollSpeed;
                    float _Alpha;

                    //구조체 vertex to float
                    struct v2f
                    {    //16 +12+12+16 = 56 -> 64 패딩필요
                        float4 vertex : SV_POSITION;
                        float3 worldPos : TEXCOORD0;
                        float3 viewVec : TEXCOORD1;
                        float4 sphere : TEXCOORD2;
                        float2 padding :  TEXCOORD3;
                    };

                    v2f vert(appdata_base v)
                    {
                        v2f o;
                        o.vertex = UnityObjectToClipPos(v.vertex); //투영까지
                        o.worldPos = mul(unity_ObjectToWorld, v.vertex).xyz; //월드좌표
                        o.viewVec = WorldSpaceViewDir(v.vertex); //모델좌표-> 월드좌표 방향
                        o.sphere.xyz = mul(unity_ObjectToWorld, float4(0, 0, 0, 1)).xyz; //곱셈 모델의매트릭스 * 알파값의 xyz 값 추출
                        return o;
                    }

                    float noise(float3 p)
                    {
                        // 0.366025404=(sqrt(3) - 1) / 2;
                        // 0.21132486 =(3-sqrt(3))/6;

                        float f = frac(p.y); //소수점 반환 
                        float i = floor(p.y); //내림
                        float2 rg = tex2Dlod(_NoiseTex, float4(p.xz + float2(0.37, 0.21) * i, 0, 0) / 64).xy; //민맵
                        return lerp(rg.x, rg.y, f);
                    }

                    float fbm(float3 p)  //Fractal noise 노이즈 흐릿해서 보완하기위해
                    {
                        p *= _Frequency;
                        float v = 0;
                        float4 offset = _Time * _ScrollSpeed;
                        v += noise(p + offset.y);
                    #if OCTAVES_2 | OCTAVES_3 | OCTAVES_4 | OCTAVES_5
                        p *= 2;
                        v += noise(p + offset.z) / 2; p *= 2;
                    #endif

                    #if OCTAVES_3 | OCTAVES_4 | OCTAVES_5
                        v += noise(p + offset.z) / 4; p *= 2;
                    #endif

                    #if OCTAVES_4 | OCTAVES_5
                        v += noise(p + offset.w) / 8; p *= 2;
                    #endif

                    #if OCTAVES_5
                        v += noise(p + offset.w) / 16; p *= 2;
                    #endif
                        v = 0.5 + 0.5 * v;
                        return v;
                    }

                    float distf(float4 sphere, float3 p) {
                        return distance(p, sphere.xyz) - _Radius - fbm(p);
                    }

                    float4 march(float4 sphere, float3 p, float3 v)
                    {
                        float dist;
                        for (int i = 0; i < PRIMARY; ++i) {
                            dist = distf(sphere, p);
                            if (dist < THRESHOLD) return float4(p, 0);
                            p -= v * (dist + .02);
                        }
                        return float4(-100, -100, -100, -100);
                    }

                    float2 heat(float4 sphere, float3 p, float3 d)
                    {
                        float heat = 0;
                        float dens = 0;
                        float fac = .5;
                        d *= HEATSTEP;
                        for (int i = 0; i < SECONDARY; ++i) 
                        {
                            float dis = distf(sphere, p);
                            if (dis <= THRESHOLD) 
                            {
                                heat += pow((_Radius - distance(p, sphere.xyz) + 2.5) * fac * _Heat, 3);
                                fac *= .25;
                                dens += HEATSTEP * 2;
                                p -= d;
                            }
                            else 
                            {
                                p -= d * 3;
                            }

                        }
                    return float2(heat, dens);
                    }

                half4 frag(v2f i) : COLOR
                {
                    float4 m = march(i.sphere, i.worldPos, normalize(i.viewVec));

                    #if SCATTERING_OFF
                    float heatfac = smoothstep(_Radius + .5, _Radius + 1.5, distance(m.xyz, i.sphere.xyz)) / _Heat;
                    half4 col = tex2Dlod(_MainTex, float4(1 - heatfac, 0, 0, 0));
                    col.w = saturate(_Alpha);
                    #elif SCATTERING_ON
                    float2 hd = heat(i.sphere, m.xyz, normalize(i.viewVec));
                    half4 col = tex2Dlod(_MainTex, float4(hd.x, 0, 0, 0));
                    col.w = saturate(saturate(hd.y) * _Alpha);
                    #endif
                    clip(m.w);
                    return col;
                }
                ENDCG
            }
        }
        FallBack off
    }

    ```

    </details>

    <details markdown =1>
    <summary> 프렉탈 패턴 시스템 C# 코드 </summary>

    ```c#

    namespace FireBall
    {
        public delegate void FractalFireCollisionDelegate(FractalFireBallSystem script, Vector3 pos);
        public class FractalFireBallSystem : SkillScript, ICollisionHandler
        {
        [Header("FireBallSystem")]
            [Tooltip("충돌 및 물리에 사용될 개체")]
            public GameObject ColliderObject;

            [Tooltip("충돌시 재생되는 소리")]
            public AudioSource CollisionSound;

            [Tooltip("충돌시 재생하는 파티클 시스템")]
            public ParticleSystem ExplosionParticleSystem;

            [Tooltip("충돌시 폭발 반경")]
            public float ExplosionRadius = 0.0f;

            [Tooltip("충돌시 폭발하는 힘")]
            public float ExplosionForce = 0.0f;

            [Tooltip("사전에 시전 에니메이션이 있을겨우 전송 지연")]
            public float ColliderDelay = 0.0f;

            [Tooltip("충돌의 속도")]
            public float ColliderSpeed = 0.0f;

            [Tooltip("콜라이더의 진행 방향")]
            public Vector3 Direction = Vector3.forward;

            [Tooltip("콜라이더가 충돌 할 수 있는 레이어")]
            public LayerMask CollisionLayers = Physics.AllLayers;

            [Tooltip("충돌시 파괴되는 게임오브젝트")]
            public GameObject[] DestroyGameObjectOnCollision;

            [HideInInspector]
            public FractalFireCollisionDelegate CollisionDelegate; //델리게이트

            private bool collided=false;

            private IEnumerator PhysicsTransform() //방향 각도 
            {
                yield return new WaitForSeconds(ColliderDelay); //지연시간 후에 시작

                Vector3 dir = Direction * ColliderSpeed; //방향
                dir = ColliderObject.transform.rotation * dir;
                ColliderObject.GetComponent<Rigidbody>().velocity = dir; //한번뿐이니 괜찮음
                foreach (GameObject o in DestroyGameObjectOnCollision)
                {
                    o.GetComponent<Rigidbody>().velocity = dir;
                }
            }

            // Start is called before the first frame update
            protected override void Start()
            {
                base.Start();
                StartCoroutine(PhysicsTransform()); //콜라이더 이후 딜레이
            }

            public void HandleCollision(GameObject obj, Collision c) //인터페이스 상속받은 콜라이더 충돌시
            {
                if (collided) //충돌중이라면
                {
                    return; //충돌 리턴
                }

                collided = true;
                Stop(); //멈추고

                // 오브젝트 파괴
                if (DestroyGameObjectOnCollision != null)
                {
                    foreach (GameObject o in DestroyGameObjectOnCollision)
                    {
                        GameObject.Destroy(o, 0.01f);// 오브젝트파괴
                    }
                }

                if (CollisionSound != null)
                {
                    CollisionSound.Play(); //충돌 소리 재생
                }

                if (ExplosionParticleSystem && ExplosionParticleSystem.gameObject.activeSelf != false && c.contacts.Length != 0)
                {
                    ExplosionParticleSystem.transform.position = c.contacts[0].point;
                    ExplosionParticleSystem.Play();
                    SkillScript.CreateExplosion(c.contacts[0].point, ExplosionRadius, ExplosionForce); //폭발
                    if (CollisionDelegate != null) //델리게이트가 있다면
                    {
                        CollisionDelegate(this, c.contacts[0].point); //전달
                    }
                }
            }
        }
    }

    ```

    </details>

    <br>

    ![충돌후 폭발 파티클 적용](https://drive.google.com/uc?export=view&id=1kaXvofk0-I2jQaj_zOdKaFCZJhs0e4PZ){: width="100%" }
    *충돌후 폭발 파티클 적용*

    ![Fx 폭발 파티클 적용](https://drive.google.com/uc?export=view&id=1qC10aQYLryGzkhfUqTSbCJs-NLKrGZpK){: width="100%" }
    *Fx 폭발 파티클 적용*

<br>

### <green1_h3><red1_error> 인스펙터 에디터창 변경 </red1_error></green1_h3>

- 이 파트는 교수님의 과제로 인하여 만들었지만, 당시에는 만드는 이유를 알 수가 없었습니다.

    ![인스펙터 에디터창](https://drive.google.com/uc?export=view&id=1ErRp0cfeH7WEm5OL24T-zlU8LVuwNYe6){: width="100%" }

    <details markdown =1>
    <summary> 프렉탈 패턴 시스템 C# 코드 </summary>

    ```c#

    namespace FireBall
    {
        [CustomEditor(typeof(FractalFireBall))]
        [CanEditMultipleObjects]
        public class FractaFireBallEditor : Editor
        {
            bool materialAdvence = false;

            SerializedProperty mainTex;
            SerializedProperty noiseTex;
            SerializedProperty material;

            SerializedProperty heat;
            SerializedProperty alpha;

            SerializedProperty speed;
            SerializedProperty frequency;
            SerializedProperty scattering;

            SerializedProperty octaves;
            int[] octaveNums = { 1, 2, 3, 4, 5 };
            GUIContent[] octaveStrings = { new GUIContent("옥타브_1"), new GUIContent("옥타브_2"), new GUIContent("옥타브_3"), new GUIContent("옥타브_4"), new GUIContent("옥타브_5") };

            SerializedProperty quality;
            int[] qualityNums = { 0, 1, 2 };
            GUIContent[] qualityStrings = { new GUIContent("낮음"), new GUIContent("중간"), new GUIContent("높음") };

            public void OnEnable()
        {
                mainTex = serializedObject.FindProperty("TextureColor");
                noiseTex = serializedObject.FindProperty("Noise");
                material = serializedObject.FindProperty("Material");

                heat = serializedObject.FindProperty("Heat");
                alpha = serializedObject.FindProperty("Alpha");

                speed = serializedObject.FindProperty("Speed");
                frequency = serializedObject.FindProperty("Frequency");
                scattering = serializedObject.FindProperty("Scattering");

                octaves = serializedObject.FindProperty("Octaves");
                quality = serializedObject.FindProperty("Octaves");
            }

            public override void OnInspectorGUI()
            {
                FractalFireBall Mat = (FractalFireBall)target;
                serializedObject.Update();
                EditorGUI.BeginChangeCheck();

                EditorGUILayout.Space();
                if(materialAdvence = EditorGUILayout.Foldout(materialAdvence, "머테리얼"))
                {
                    EditorGUILayout.PropertyField(mainTex, new GUIContent("그라데이션"));
                    EditorGUILayout.PropertyField(noiseTex, new GUIContent("노멀맵(노이즈)"));
                    EditorGUILayout.PropertyField(material, new GUIContent("머테리얼"));
                }


                EditorGUILayout.Space();
                EditorGUILayout.LabelField("Tip) 검정 <-- 1=빨강 --> 흰색 ");
                EditorGUILayout.PropertyField(heat, new GUIContent("온도"));
                EditorGUILayout.Slider(alpha, 0, 1, new GUIContent("알파 값"));

                EditorGUILayout.Space();
                EditorGUILayout.PropertyField(speed, new GUIContent("노이즈 스피드"));
                EditorGUILayout.PropertyField(frequency, new GUIContent("노이즈 빈도"));
                EditorGUILayout.PropertyField(scattering, new GUIContent("노이즈 산란"));

                EditorGUILayout.Space();
                EditorGUILayout.LabelField("Tip) 옥타브 = 화면의 프리퀀시(진동수)나 구체의 정도 조절");
                EditorGUILayout.IntPopup(octaves, octaveStrings, octaveNums, new GUIContent("옥타브"));
                EditorGUILayout.IntPopup(quality, qualityStrings, qualityNums, new GUIContent("품질"));
                serializedObject.ApplyModifiedProperties();

                //셰이더 업데이트를 위해서
                if (EditorGUI.EndChangeCheck() || Event.current.commandName == "UndoRedoPerformed") //undo(취소) 이벤트 확인
                {
                    Mat.ShaderProperties();
                }

            }
        }
    }

    ```

    </details>
    
<br>

### <green1_h3> 유니티 로그인 화면 UI 제작 및 데이터 베이스 조회 </green1_h3>

- 유니티 로그인 + PHP + MySql 쿼리문으로 데이터베이스 조회: [https://youtu.be/q3 Xq106 qzb4](https://youtu.be/q3 Xq106 qzb4)
    <iframe width="100%" style="aspect-ratio:16/9" src="https://www.youtube.com/embed/q3Xq106qzb4" title="팀프로젝트 과제 - 네트워크" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" allowfullscreen></iframe>

<br>
<br>

## <green1_h2> 팀 프로젝트 과제 결과 </green1_h2>

- <span><green1_h5>성과: </green1_h5> 게임 과제 제작 </span>

<br>

### <green1_h3> 배운 점 </green1_h3>

- 카메라 프로세싱 과정에 대해서 이해하고 유니티 쉐이더를 이용하여 코드를 작성할 수 있게 되었습니다.
- 프렉탈 패턴과 파티클 빌보드의 성능을 비교해 보고 실시간과 성능의 차이에 대해 이해할 수 있게 되었습니다.
- 쿼리문으로 데이터베이스를 조회해서 로그인 처리 하는 방법에 대해서 학습했습니다.