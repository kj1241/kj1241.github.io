---
layout: post
title: "디자인 패턴에 대한 고찰"
date: 2023-02-23 19:42:15 +09:00
image: https://drive.google.com/thumbnail?id=1QgkDpoX5DrX202nm5jb1ioOiY3FAP-yF
toc: true
categories: [Other_Articles]
keywords: 디자인 패턴, 소프트웨어 공학, GOF, 프로그래밍
addsence: true
lastmod: 2024-06-01 09:00:00 +09:00
sitemap:
  changefreq : daily
  priority : 1.0
excerpt: 디자인 패턴에 관한 개인적인 경험을 바탕으로 설명합니다. 디자인 패턴의 올바른 사용법과 주의점을 다룹니다.
related_links:
---

개인적인 일 때문에 한동안 글을 적지 못했습니다. 이번에는 디자인 패턴에 관해 이야기해 보려고 합니다. 이 글은 다소 개인적인 경험을 바탕으로 작성되었으며, 제 개인적인 의견이므로 참고해 주시면 감사하겠습니다.

<br>

---

<br>

## <cpp_h2> TensorFlow: 디자인 패턴이란? </cpp_h2>

디자인 패턴은 소프트웨어 공학에서 자주 사용되는 패턴을 정리한 개념입니다. 이 개념은 GOF(Gang of Four)로 알려진 네 명의 저자가 정리하여 출판한 책에서 시작되었습니다. 이 책에서는 크게 23가지의 패턴을 소개하고 있습니다.

코딩을 처음 배우는 사람들이 디자인 패턴에 대해 묻는다면 저는 흔쾌히 긍정적으로 이야기합니다. 디자인 패턴 자체는 큰 문제가 되지 않으며, 오히려 코드의 로직을 짜는 데 있어 좋은 가이드라인이 될 수 있습니다.

<br>
<br>

## <cpp_h2> 대학교 시절의 경험 </cpp_h2>

대학교 4학년 때 배운 디자인 패턴은 다양한 상황에서 유용하게 활용될 수 있었습니다. 예를 들어, 프로토타입 패턴을 이용한 몬스터 생성, 상태 패턴을 이용한 애니메이션 상태 관리, 게임 루프 패턴, 메모리 풀 등은 로직을 처음 구성하는 사람들에게 매우 효율적인 길을 제시해 줍니다.

하지만 디자인 패턴을 무작정 사용하는 것은 로직의 본래 목적을 이해하는 데 방해가 될 수 있습니다. 이 점을 설명하기 위해 제 경험담을 소개하려고 합니다.

<br>

### <cpp_h3> 경험담 </cpp_h3>

대학교 2학년 때의 일입니다. 당시 수업에서는 WinAPI를 이용하여 게임을 만드는 과제가 있었습니다. WinAPI를 코딩해 본 분들은 아시겠지만, 윈도의 명령어를 처리해 주는 WinAPI의 프로시저 부분을 선언하려면 전역 변수나 전역 함수로 선언해야 합니다. 저는 이 부분이 불편하여 프로시저를 클래스의 멤버 함수로 선언하여 사용하고 싶었습니다.

하지만 WinAPI 코드를 클래스에 선언하면 생성하는 부분에서 에러가 발생합니다. 비슷한 경우로 beginThread 함수를 사용하여 멀티 스레드를 만들 때도 클래스 멤버 함수를 사용하면 에러가 생깁니다. 이 문제에 대해 교수님께 질문했지만, 당시에는 왜 그렇게 코드를 작성하려고 하는지 이해받지 못했습니다.

저는 명확한 목적이 있었습니다. 전역 함수로 사용할 때보다 클래스 안에 있을 때 보안성이 올라가고, 코드의 분업화가 용이해집니다. 하지만 클래스화했기 때문에 전역 함수로 사용할 때보다 동작이 느려질 수 있습니다.

2012년 당시에는 이런 코드를 작성하는 방법을 알려주는 사람이 없었고, 인터넷에서도 관련 정보를 찾기 어려웠습니다. 하지만 저는 포기하지 않았고, 디버깅을 통해 클래스의 this 포인터가 API를 이용하여 코드를 호출하는 데 방해된다는 것을 깨달았습니다.

<br>

### <cpp_h3> 디자인 패턴 같지만 목적이 다른 형태의 코드 </cpp_h3>

![메모리 구조]({{ site.google_drive }}1QgkDpoX5DrX202nm5jb1ioOiY3FAP-yF{{ site.google_drive_end }}){:width="100%" height="auto" loading="lazy"}
*<cpp_h6>메모리 구조</cpp_h6>*

winAPI를 클래스로 만들기 위해서는 static을 이용해야 합니다. 그 이유는 프로시저가 스택리스이고 스택을 공유하기 위해서는 정적메모리 위치에 올려놔야 하기 떄문입니다. 따라서 두가지 방법이있습니다. 첫째는 정적 클래스를 사용하는 것이고, 둘째는 멤버 함수의 this 포인터를 대체할 수 있는 정적 WinAPI 포인터를 만들어 사용하는 것입니다.

예를 들어,

```cpp

// WinAPI.h
class WinAPI {
public:
    WinAPI();
    ~WinAPI();
    static WinAPI* pWinAPI;
    void WinProc(...);
};

// WinAPI.cpp
#include "WinAPI.h"

WinAPI* WinAPI::pWinAPI = nullptr;

WinAPI::WinAPI() {
    pWinAPI = this;
}

WinAPI::~WinAPI() {
    pWinAPI = nullptr;
}

static void sWinProc(...) {
    WinAPI::pWinAPI->WinProc(...);
}

```

위와 같은 방식으로 코드를 작성할 수 있습니다. 저는 하나뿐인 객체를 만드는 목적을 가지고 코드를 작성하지 않았지만 싱글톤 객체와 형태가 비슷합니다. 하지만 이는 싱글톤의 목적과는 전혀 다릅니다.

<br>
<br>

## <cpp_h2> 결론 </cpp_h2>

디자인 패턴은 현업에서 자주 사용되는 패턴을 정리한 것입니다. 그러나 이는 수학 공식처럼 명확한 것이 아닙니다. 프로그래머가 작성하는 코드에는 명확한 목적이 담겨 있으며, 그 목적을 이해하는 것이 중요합니다. 디자인 패턴에 너무 몰입하면 로직의 본래 목적을 이해하는 데 방해가 될 수 있습니다. 그러나 디자인 패턴을 적절히 활용하면 좋은 가이드라인이 될 수 있습니다.

읽어주셔서 감사합니다.