---
layout: post
title: "하나비 프로젝트(리듬 게임) 개발 로그 1 - 들어가기 전에"
date: 2023-01-15 00:10:48 +0900
image: https://drive.google.com/thumbnail?id=1GHoI82k23TliVVdvYGe_0VAXj0OvNeYn
toc: true
categories: [Unity]
tags: [C#, Unity, Rhythm Game]
keywords: C#, Unity, Rhythm Game, game log
addsence: true
excerpt: Unity 및 C#을 활용한 리듬게임 '하나비 프로젝트'의 개발 로그입니다. 용어, 구성 방식, 프로세스를 소개하며, 게임잼 동안의 경험과 과정을 공유하고 있습니다.
related_links:
    - url: /game_jam/HANABI.html
    - url: /unity/HANBI-Refactoring_log2.html
    - url: /unity/HANBI-Refactoring_log3.html
    - url: /unity/HANBI-Refactoring_log4.html
---

## <unity_h2>1. 들어가기 전 용어 정리</unity_h2>

본격적으로 들어가기전에 리듬게임 제작에 생소할 수 있는 용어들을 적어보겠습니다.  

<br>

### <unity_h3>1) 리펙토리 이란</unity_h3>

소프트웨어 코드의 구조를 변경하거나 개선하여 가독성을 높이고 유지보수를 쉽게 만드는 과정을 말합니다. 리팩토링은 기능을 변경하지 않으면서도 코드의 품질을 향상시키는 것을 목표로 합니다. 이는 코드를 더 이해하기 쉽게 만들고, 버그를 줄이며, 새로운 기능을 추가할 때의 비용을 낮춥니다.

- <unity_h5>가독성 향상:</unity_h5> 코드를 더 이해하기 쉽게 만들어 유지보수가 용이하도록 합니다.  
    변수명, 함수명 등을 명확하게 지어 코드의 의도를 더 명확하게 전달하도록 개선합니다. 
- <unity_h5>중복 코드 제거:</unity_h5> 중복된 코드를 찾아 제거하여 코드의 길이를 줄이고 유지보수를 쉽게 만듭니다.
- <unity_h5>모듈화 및 구조 개선:</unity_h5> 코드를 더 작은 모듈로 분할하고 모듈 간의 관계를 명확하게 정의하여 코드의 구조를 개선합니다.
- <unity_h5>성능 최적화:</unity_h5> 효율적인 알고리즘을 선택하거나 비효율적인 부분을 개선하여 프로그램의 성능을 향상시킵니다.
- <unity_h5>버그 수정:</unity_h5> 코드를 분석하고 버그를 찾아 수정함으로써 소프트웨어의 안정성을 향상시킵니다.

<br>

#### <unity_h4>리펙토리의 이유</unity_h4>

과거에 비해서 현재의 코드스타일이 변화했기 때문입니다. (유지보수관점, 코드설계 등의 관점) 3일이라는 게임 잼에서 완성도를 목적으로 프로그램을 급박하게 작성하여 <unity_h5>틀린 오타, 작성 안 한 주석, 하드코딩들의 개선</unity_h5>을 하기 위해서입니다.


<br>
 
### <unity_h3>2) 노드</unity_h3>

플레이어의 입력을 나타내는 요소입니다. 플레이어는 노드가 나타날 때 정확한 타이밍에 해당하는 입력을 해야 합니다. 노드는 일반적으로 음악의 비트나 리듬에 맞춰 플레이어에게 제시됩니다. 다양한 싱글, 롱 , 슬라이더, 패턴, 특수 노드등 다양한 특성의 노드가 존재 할 수 있으며, 주로 음표로 표현됩니다.

- 범용적인 용어. 리듬게임에서는 음표를 뜻합니다. 
    노트라고도 부르기도 합니다.
- 화면에 표시되는 플레이어의 입력을 나타내는 요소입니다.  

<br>
 
### <unity_h3>3) 채보</unity_h3>

리듬게임에서 음악적인 패턴이나 시퀀스를 나타내는 요소입니다. 채보를 만드는 사람에 따라 난이도와 정밀도가 다를 수 있으며, 게임 화면에 표시되어 플레이어가 입력해야 합니다.

- 리듬게임의 꽃, 원래 용어는 음악을 듣고 악보로 옮겨 적는 방식 이러한 채보를 제작하는 사람에 따라서 난이도와 정밀함이 나뉩니다.  
- 게임 화면에 나타나는 음악적인 패턴이나 시퀀스를 나타냅니다.


<br>
<br>

## <unity_h2>2. 게임의 기본 구성 방식 및 역활</unity_h2>

게임의 메인 화면을 구성하는데 있어서 사용된 방식을 설명하겠습니다.

![게임 구성 방식]({{ site.google_drive }}1GHoI82k23TliVVdvYGe_0VAXj0OvNeYn{{ site.google_drive_end }}){:width="100%" height="auto" loading="lazy"}
*<unity_h6>게임 구성 방식</unity_h6>*

저는 리듬좋아 팀에서 메인화면을 구성하는 프로그래머로 참여하였습니다. 주요 역할은 노드 생성 로직 설계 및 구현, 스파인 애니메이션 API 연동 로직 설계 및 구현, 그리고 점수 판정 로직 설계 및 구현입니다.

<br>
<br>

## <unity_h2>3. 게임잼 진행 당시 코드 개발 프로세스</unity_h2>

코드를 개발하는 과정은 다음과 같은 프로세스를 거쳤습니다.

![게임 구성 방식]({{ site.google_drive }}1jm1aBEryNzu25wQQvseeXSCYcVNqCrU1{{ site.google_drive_end }}){:width="100%" height="auto" loading="lazy"}
*<unity_h6>게임 구성 방식</unity_h6>*

1. 노드 생성 및 설계 구현: 노드를 생성하고 그에 필요한 로직을 설계하고 구현했습니다.
2. 스파인 애니메이션 설계 및 구현: 게임에 필요한 애니메이션을 스파인을 통해 설계하고 연동하는 작업을 수행했습니다.
3. 점수 판정 로직 설계 및 구현: 플레이어의 입력을 판정하여 점수를 계산하는 로직을 설계하고 구현했습니다.
4. 총 점검 및 단위 테스트: 모든 기능을 점검하고 단위 테스트를 통해 문제가 있는지 확인했습니다.

위의 표는 제가 게임잼 당시 진행했던 코드 개발  프로세스 모델입니다. 총 4단계로 이루어져 있습니다.

<br>
<br>

## <unity_h2>4. 제작전 회의</unity_h2>

회의를 통한 이러한 팀 내 의사소통과 협업은 프로젝트의 성패에 큰 영향을 미칩니다. 여러 분야의 전문가들 간에 의견을 공유하고 합의하는 것은 효율적이며 문제를 미리 예방할 수 있는 좋은 방법이였습니다. 
  
<br>
 
### <unity_h3>1) 디자이너와의 회의</unity_h3>

<unity_h5>메인화면 구성:</unity_h5> "리듬세상처럼 구성"이라는 목표를 설정했으나, 개발자가 게임을 경험하지 못한 상태에서의 제안이었습니다. 따라서 만들 수 있는 작은 부분들을 만들어서 완성도를 높이고 살을 붙이는 방법으로 만들자고 합의 하였습니다.

<br>
 
### <unity_h3>1) 채보 담당 프로그래머와의 회의</unity_h3>

<unity_h5>로직 주고받기:</unity_h5> 5키 리듬게임으로의 결정과 파일 입출력 방식을 통한 노드 구성은 프로젝트의 핵심 부분을 잘 정의한 것입니다. 이러한 핵심 로직의 결정은 전체적인 개발을 원활하게 이끌어갈 수 있도록 도움을 줬습니다.


<br>
 
### <unity_h3>1) 아티스트와의 회의</unity_h3>
<unity_h5>배경과 동작 구상:</unity_h5> 아티스트의 구상도를 기반으로 로직을 구현하고, 오브젝트를 유니티 프리팹 형태로 작업물을 받는 것은 협업의 원활한 진행을 위해 중요한 결정입니다. 이는 아티스트와 개발자 간의 소통을 원활하게 해주어 예상치 못한 문제를 방지할 수 있었습니다.

<br>
<br>

## <unity_h2>5. 여담</unity_h2>

초기 회의에서의 명확한 의사소통과 합의는 프로젝트의 성공을 좌우할 수 있습니다. 작은 부분부터 세밀하게 협의하고 나아가 점진적인 방식으로 개발을 진행하는 것은 팀의 효율성을 높일 수 있었습니다.
