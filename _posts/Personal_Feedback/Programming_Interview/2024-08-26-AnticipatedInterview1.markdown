---
layout: post
title: "2024.08.26 - 인터뷰 예상 질문 연습하기1"
date: 2024-08-21 21:00:00 +09:00
image: https://drive.google.com/thumbnail?id=
toc: true
categories: [Programming_Interview]
keywords: 
lastmod: 2024-08-21 21:00:00 +09:00
sitemap: 
  changefreq : daily
  priority : 0.1
addsence: true
excerpt: 
related_links:
---

## <feedback_h2>1. 기술적 문제</feedback_h2>

<br>

### <feedback_h3>1) C#에서 가장 많이 사용하는 기능이나 라이브러리는 무엇이며, 그것을 어떻게 활용했는지 설명해 주세요.</feedback_h3>

<p><feedback_h5>내가 생각한 키워드:</feedback_h5> 코루틴</p>
<p><feedback_h5>이유:</feedback_h5> c#에서 가장 강력한 기능중 하나라고 생각해서 </p>

<p><feedback_h5>내가 고민해서 작성한 답:</feedback_h5> 제가 많이 사용했던 기능은 코루틴입니다. 코루틴은 반복된 동작을 간편하게 작성할 수 있게 해줍니다. 또한 시분할 시스템의 일종으로, 메인 로직과 별도로 프레임별로 특정작업하기에 용의합니다.

예를들어 저는 코루틴을 하나비 프로젝트에서 사용했습니다. 하나비 프로젝트는 리듬게임인데, 노드가 일정한 간격으로 생성되어야 했기 때문에 코루틴을 사용하여 메인로직에 부담이 되지 않게 처리하였습니다. </p>

<p><feedback_h5>AI 훈수:</feedback_h5> 마무리 부분 추가</p>
- 이처럼 코루틴은 비동기 작업이나 지연 작업이 필요한 경우 매우 효과적으로 활용할 수 있는 기능입니다.

<br>

### <feedback_h3>2) 자료구조와 알고리즘의 중요성에 대해 설명하고, 이를 실제 프로젝트에서 어떻게 적용했는지 사례를 들어 설명해 주세요. </feedback_h3>

<p><feedback_h5>이런 질문이 어려운 이유:</feedback_h5> 문항 자체가 나에게 애매하고 어려움, 마치 묻는게 '3년전 점심식사 뭐먹었어요?'라고 묻는것과 동일한 난이도라고 생각합니다. 자료구조와 알고리즘이 특별한게 아닌데 특별하게 취급해야하는게 어려운거 같습니다.</p>

<p><feedback_h5>내가 생각한 키워드:</feedback_h5> 라벨링 매니져</p>
<p><feedback_h5>이유:</feedback_h5> 그나마 작업했던것 중 사람들이 쉽게 이해할 수 있는 것일 꺼 같아서 </p>

<p><feedback_h5>내가 고민해서 작성한 답:</feedback_h5> 제가 생각하기에 자료구조는 데이터가 어떻게 구조적으로 이루어져 있는지 한눈에 알 수 있게 해줍니다. 또한 알고리즘은 직면한 문제들을 어떻게 풀어갈껀지의 키입니다. 

저의 같은 경우에는 알고리즘을 만들었습니다. AI학습을 위해서 라벨링이라는 것을 만들어야 했고, 라벨링은 관리하기 위해서 라벨링 매니저를 만들었습니다. 이 과정에서 랜더링과 계산을 최적화를 위해서, 라벨링 매니저의 리스트에서 z 순으로 sort 정렬하였고 앞에 있는 라벨링 오브젝트와 뒤에있는 라벨링 오브젝트를 비교하면서 불필요한 부분은 렌더링 하지 않도록 비활성화 처리를하여 최적화 하였습니다.</p>

<p><feedback_h5>AI 훈수:</feedback_h5> 명확하고 구체적인 설명이 필요 (같은 말인데도 만들기 어렵다...)</p>

**자료구조와 알고리즘의 중요성은 데이터 처리의 효율성과 직결된다고 생각합니다.**

<p>자료구조는 데이터를 효율적으로 저장하고 관리하는 방법을 제공하며, 이를 통해 프로그램의 성능을 크게 향상시킬 수 있습니다. 알고리즘은 주어진 문제를 해결하는 절차를 정의하며, 적절한 알고리즘을 선택하고 구현하는 것이 문제 해결의 핵심이라고 생각합니다.

실제로 제가 참여했던 프로젝트에서, AI 학습 데이터를 라벨링하는 작업을 최적화해야 했습니다. 이 과정에서 라벨링 오브젝트를 효율적으로 관리하기 위해 자료구조와 알고리즘을 활용했습니다.
라벨링 오브젝트가 많아지면서 불필요한 랜더링이 성능 저하의 원인이 되었는데, 이를 해결하기 위해 라벨링 오브젝트들을 z축을 기준으로 정렬한 후, 인접한 오브젝트 간의 비교를 통해 화면에 보이지 않는 오브젝트는 렌더링하지 않도록 비활성화 처리하였습니다. 이를 통해 렌더링 부하를 줄이고 성능을 크게 개선할 수 있었습니다.

이처럼 자료구조와 알고리즘을 적절히 활용하면 성능 최적화뿐만 아니라 유지보수성도 높아져, 프로젝트의 전반적인 효율을 크게 개선할 수 있다고 생각합니다.
~~(이렇게 말할 자신이 없다...)~~</p>

<br>

### <feedback_h3>3) 3D 그래픽스에서 사용하는 수학적 개념 중 가장 중요한 것은 무엇이라고 생각하며, 그것을 어떻게 프로젝트에 적용했는지 설명해 주세요. </feedback_h3>

<p><feedback_h5>이런 질문이 어려운 이유:</feedback_h5> 수학적 개념중 가장 중요한 것은 사람마다 다를 수 있는데 이게 정답이 있나 하는 생각 가장 기초적으로 오브젝트의 상태를 설명할수 있는 행렬도 중요하고, 3D->2D로 변경하는 투영도 중요하고, 요즘 같은 시기에는 실사와 같은 렌더링이 중요하기 때문에 조명 계산도 중요함, 솔직히 중요도로 따지만 모르겠음 그러면 면접관이 생각하는 중요도를 파악해야되는데 이게 되나.... 아니면 생각나는대로 다 말할까...순간 생각하려고하면 머리속이 꼬일꺼 같은데</p>

<p><feedback_h5>내가 생각한 키워드:</feedback_h5> 행렬</p>
<p><feedback_h5>이유:</feedback_h5> 그래픽스의 가장 기초적인 개념이기 때문에</p>

<p><feedback_h5>내가 고민해서 작성한 답:</feedback_h5> 3D 그래픽스에서 사용하는 수학점 개념중 가장 중요한 것은 행렬이라고 생각합니다. 그 이유는 오브젝트의 상태를 가장 잘 나타낼 수 있는 부분이라고 생각하기 때문입니다. 

제가 블로그에서 GPU 인스턴싱을 설명하기 위해서 mesh를 가지고 오브젝트를 만들어야 될 상황이 있었습니다. 이때 4*4 행렬을 만들어서 이동, 회전, 크기변경등을 정의 할 수 있었습니다. 

이처럼 행렬 하나로 오브젝트의 상태와 계산을 보다 편리하게 만들어 준다고 생각합니다.</p>

<p><feedback_h5>AI 훈수:</feedback_h5> 이해도를 보여주는 방식으로 수정(같은 말인데도 만들기 어렵다...)</p>

**3D 그래픽스에서 가장 중요한 수학적 개념 중 하나는 행렬(Matrix)이라고 생각합니다.**

<p>행렬은 3D 공간에서 오브젝트의 위치, 회전, 크기 변화를 효과적으로 표현할 수 있는 도구입니다. 이를 통해 다양한 변환을 단일 구조 안에서 수행할 수 있기 때문에 3D 그래픽스에서 필수적인 역할을 합니다.

제가 블로그에서 작성한 코드 중 하나에서는, GPU 인스턴싱을 사용해 수많은 오브젝트를 효율적으로 렌더링해야 했습니다. 이때 각 오브젝트의 변환 상태를 관리하기 위해 4x4 변환 행렬을 사용했습니다. 이 행렬을 통해 오브젝트의 위치를 이동시키거나 회전, 크기 변경 등의 변환을 간단하게 적용할 수 있었습니다. 예를 들어, 행렬의 특정 값들을 조작함으로써 각 오브젝트가 화면 내에서 서로 다른 위치에 렌더링되도록 하였으며, 여러 개의 오브젝트가 동시에 변경될 수 있도록 최적화했습니다.

이처럼 행렬은 복잡한 3D 변환을 간단하고 효율적으로 처리할 수 있도록 도와주기 때문에 3D 그래픽스에서 매우 중요한 수학적 개념이라고 생각합니다.</p>
~~(이렇게 말할 자신이 없다니깐...)~~

<br>

### <feedback_h3>4) 유니티를 사용한 3D 프로젝트 경험에 대해 설명해 주세요. 프로젝트의 목표, 사용된 기술, 직면했던 도전 과제, 그리고 그 문제를 어떻게 해결했는지 말씀해 주세요. </feedback_h3>

<p><feedback_h5>이런 질문이 어려운 이유:</feedback_h5> 당시 분명 어려웠던 점은 존재합니다. 하지만 시간이 지남에 따라서 그 부분이 많이 미화되고 풍화되었습니다. 그래서 더욱 어렵게 느껴지는거 같습니다. </p>

<p><feedback_h5>내가 생각한 키워드:</feedback_h5> 라이더 모의</p>
<p><feedback_h5>이유:</feedback_h5> 3D 부분을 보다 효과적으로 나타내 줄 수 있을 것 같아서?</p>

<p><feedback_h5>내가 고민해서 작성한 답:</feedback_h5> ATRC 프로젝트는 실제 군함이 AI를 이용해서 군집모의를 하기 위해서 시뮬레이션에서 적용하는 프로젝트 입니다. 이중에서 제가 직면했던 도전과제중에 하나를 이야기하면 라이더 모의 같습니다.

저희는 유니티에서 다른 2세부(해양과학기술원)과 연동하기 위해서 유니티에서 라이더 시뮬레이션을 만들고 그 데이터를 우분투 로스 코어로 전송해야 했습니다. 원래는 오브젝트에서 수백계의 레이를 쏘아서 충돌하는 지점을 얻어와야 되지만, 제가 생각한 첫번째 방법은 이  과정을 풀기 위해서 오브젝트를 쉐이더로 이용해서 점으로 보이게 하고 그 메쉬들을 리스트를 사용해서 포인트 클라우드로 담는 것이였습니다. 그리고 미들웨어 ICOP를 사용해서 포인트 클라우드를 로스로 전송 보냈고 받는 부분을 작성하였습니다. 처음에는 라이더를 어떻게 모사해야되는지 몰라서 로스에 있는 도큐먼트를 찾아서 구조를 생각하고 시뮬레이션에 적용하여 완성하였습니다. 이러고 차후 메쉬 세이더 부분을 수백개의 레이로 바꿔서 포인트 클라우드 변경하고 적용하였습니다.</p>

~~(아니 이렇게 작성하면 너무 듣는사람이 어렵지 않냐고 무슨 개념인지도 설명하기 힘든데)~~

<p><feedback_h5>AI 훈수:</feedback_h5> 간결하고 체계적으로 정리 </p>

**ATRC 프로젝트는 실제 군함이 AI를 이용해 군집 모의를 시뮬레이션하는 것을 목표로 하는 프로젝트입니다.**

<p>이 프로젝트에서 제가 맡았던 주요 도전 과제 중 하나는 유니티 내에서 라이더(LiDAR) 시뮬레이션을 구현하는 작업이었습니다. 이 작업은 2세부인 해양과학기술원과의 협업을 위해 유니티에서 생성한 데이터를 우분투 기반의 ROS 코어로 전송해야 하는 복잡한 시스템이었습니다.

처음에는 라이더 센서의 작동 방식을 모사해야 했습니다. 일반적으로 오브젝트에서 수백 개의 레이를 쏘아 충돌 지점을 추적하는 방식이지만, 성능 이슈를 고려하여 더 효율적인 방법을 찾아야 했습니다. 제가 처음 시도한 방법은 오브젝트를 쉐이더를 이용해 점으로 표현하고, 해당 메쉬 데이터를 포인트 클라우드로 변환해 리스트에 담는 것이었습니다. 그런 다음, 미들웨어인 ICOP을 사용하여 포인트 클라우드 데이터를 ROS로 전송하고, 수신된 데이터를 처리하는 시스템을 구현했습니다.

이 과정에서 라이더의 구현 방식에 대해 처음에는 막막했지만, ROS의 도큐먼트를 참고해 라이더 데이터 구조를 파악하고 이를 시뮬레이션에 성공적으로 적용할 수 있었습니다. 이후에는 초기 방법을 더욱 발전시켜, 실제 라이더 센서처럼 수백 개의 레이를 쏘아 포인트 클라우드를 생성하는 방식으로 개선하였습니다.

이 경험을 통해 실시간 데이터 전송과 시뮬레이션 환경에서의 라이더 구현에 대한 깊은 이해를 얻게 되었고, 프로젝트의 목표를 성공적으로 달성할 수 있었습니다.</p>

~~(난 이렇게 못 말할꺼 같은데...)~~

<br>

### <feedback_h3>5) DirectX와 OpenGL의 차이점에 대해 설명하고, 각각의 기술을 언제 사용하는 것이 더 적합한지 논의해 보세요.</feedback_h3>

<p><feedback_h5>이런 질문이 어려운 이유:</feedback_h5> DirectX와 OpenGL의 차이점 이식성 밖에 더 있나? </p>

<p><feedback_h5>내가 생각한 키워드:</feedback_h5> 이식성</p>
<p><feedback_h5>이유:</feedback_h5> 솔직히 쓰고 싶은 쓰는게 맞지 않나?</p>

<p><feedback_h5>내가 고민해서 작성한 답:</feedback_h5> DirectX와 OpenGL에 차이는 이식성에 있는거 같습니다. DirectX는 윈도우에서 사용할 때 가장 강력한 기능입니다. 반면 OpenGL은 다양한 플랫폼에서 사용할 수 있습니다.</p>

<p><feedback_h5>AI 훈수:</feedback_h5> 자연스럽게 말할 수 있는 형식 </p>

**DirectX와 OpenGL의 차이는 크게 이식성과 플랫폼 지원에서 두드러진다고 생각합니다.**

<p>먼저, DirectX는 Microsoft에서 개발한 API로, Windows와 Xbox 같은 플랫폼에서 가장 강력한 기능을 발휘합니다. 특히 Direct3D는 Windows 환경에 최적화되어 있어서 게임 개발에 많이 사용되고, 성능 최적화도 매우 뛰어납니다. 하지만 이식성이 제한적이어서 주로 Windows 생태계에서만 사용됩니다.

반면에, OpenGL은 크로스 플랫폼 지원이 강점입니다. Windows, macOS, Linux, iOS, Android 등 다양한 운영체제에서 사용할 수 있기 때문에 멀티플랫폼 애플리케이션 개발에 적합합니다. 예를 들어, 여러 운영체제에서 동일한 그래픽 애플리케이션을 실행해야 하는 경우 OpenGL이 더 적합합니다.

따라서, Windows 전용의 고성능 게임이나 애플리케이션을 개발할 때는 DirectX가 적합하고, 여러 플랫폼을 지원해야 하는 프로젝트에서는 OpenGL이 더 유리하다고 생각합니다.</p>

~~(같은 말도 이렇게 풀어쓰는거 힘들꺼 같은데..)~~

<br>

### <feedback_h3>6) 객체지향 프로그래밍(OOP)의 4대 원칙을 설명하고, 이를 어떻게 실무에 적용했는지 구체적인 예를 들어 설명해 주세요.</feedback_h3>

<p><feedback_h5>이런 질문이 어려운 이유:</feedback_h5> 실전에서 객체지향 프로그래밍 4대원칙을 생각하면서 코드 짜는사람이 누가 있냐고 이게 말이되는 질물인가? 언제부터 4대 원칙이 중요해 젔는데</p>

<p><feedback_h5>내가 생각한 키워드:</feedback_h5>X</p>
<p><feedback_h5>이유:</feedback_h5> 면접에서 이런 문제 내면 반기 들꺼 같은데</p>

<p><feedback_h5>내가 고민해서 작성한 답:</feedback_h5> 실제 프로그래밍 코드를 작성하면서 4대원칙이 크게 중요하지 않습니다. 이론과 실전은 다릅니다. 실전에서는 이론이 아닌 문제해결능력이 필요하고 이론을 너무 몰입하게 되면 실무에서 해결 할 수 있는 문제도 매몰되기 마렵입니다. 저는 문제해결 능력위주로 코드를 작성했기 때문에 정말 죄송하게도 해당 답변에 답변 하지 못할꺼 같습니다.</p>

<p><feedback_h5>AI 훈수:</feedback_h5> 무의식 중에 쓰고 있으니 다시 답변 작성해라 </p>

4대 원칙 : 추상화 , 상속, 캡슐화, 다형성 (무의식적으로 다 쓰고 있긴 한데 이건 클래스를 어떻게 설계하나부터가 문제 아니냐고)
- 추상화: 복잡한 클래스를 단순하게 만드는 것
- 상속: 부모 클래스의 기능을 자식 클래스가 물려받아 재사용하는 원칙
- 캡슐화: 외부에서 직접 접근하지 못하게 하고, 필요한 경우에만 메소드를 통해 접근하는 방식
- 다형성: 구체적인 구현이 다른 객체들이 서로 다른 방식으로 동작할 수 있게 하는 원칙


<p><feedback_h5>다시 작성한 답:</feedback_h5> 객체지항 4대 원칙에는 다향성, 상속, 캡슐화, 추상화가 있습니다. 이는 클래스를 설계할때 생각하는 기초적인 생각입니다. 가령 다른 클래스의 메소드에 접속하기 위해서 get,set을 작성하고 클래스의 공통적인 부분을 효율적으로 작성하기 위해서 상속을 작성합니다. 그리고 복잡한 클래스를 단순하게 정의하기 위해 추상화를 사용합니다. 다형성은 오버로딩과 오버라이딩이 있는데 오버 로딩은 매소드 이름은 같지만 매개변수가 다름으로서 다른 형식읠 방법으로 계산해 줄때 사용할수 있으며 오버라이딩은 자식클래스가 부모와 다른 형질을 가질떄 사용합니다.</p>

<p><feedback_h5>AI 훈수:</feedback_h5> 깔끔하게 작성해라 </p>

- 캡슐화는 클래스 내부의 데이터를 외부에서 직접 접근하지 못하게 하여, 데이터 보호와 코드의 응집도를 높이는 원칙입니다. 이를 위해 주로 getter/setter 메서드를 사용해 데이터를 안전하게 접근하거나 수정할 수 있도록 합니다.

- 상속은 공통된 기능을 부모 클래스에 정의하고, 이를 자식 클래스에서 재사용하는 방식입니다. 이를 통해 코드의 중복을 줄이고 유지보수성을 높일 수 있습니다.

- 추상화는 복잡한 시스템을 단순하게 표현하는 원칙입니다. 중요한 기능만을 추상화하여 노출하고, 세부 구현은 감추는 방식으로 설계합니다. 이를 통해 코드의 복잡성을 줄이고, 사용자가 이해하기 쉽게 만듭니다.

- 다형성은 하나의 메서드가 다양한 형태로 동작할 수 있게 하는 원칙입니다. 여기에는 오버로딩과 오버라이딩이 있습니다.
  - 오버로딩은 같은 이름의 메서드를 매개변수의 타입이나 개수에 따라 다르게 구현하는 것을 말합니다. 예를 들어, add(int a, int b)와 add(double a, double b)처럼 같은 메서드 이름을 사용하지만 다른 방식으로 동작합니다.
  - 오버라이딩은 자식 클래스가 부모 클래스의 메서드를 재정의하는 것을 의미합니다. 상속 관계에서 부모 클래스의 메서드를 자식 클래스가 자신에게 맞게 변경하여 사용하는 것이죠. 이를 통해 자식 클래스에서 부모와 다른 동작을 구현할 수 있습니다.

~~(이렇게 깔끔하게 정리해서 못말할꺼 같은데 생각하면)~~

<br>

### <feedback_h3>7) C++ 언어의 주요 특징에 대해 설명하고, 이 언어를 사용하여 성취한 프로젝트나 해결한 문제를 공유해 주세요.</feedback_h3>

<p><feedback_h5>내가 생각한 키워드: DLL</feedback_h5>X</p>
<p><feedback_h5>이유:</feedback_h5> 속도가 빠르기 때문에 DLL로 포팅하여 이식시켰다.</p>

<p><feedback_h5>다시 작성한 답:</feedback_h5> C++은 다른 언어 인 파이썬, C#, java 보다 하드웨어 가까운 언어 입니다. 따라서 C++로 코드를 작성하게 되면 처리가 빠릅니다.

유니티에서 배의 동역학 부분을 이식시켜야되는 상황이 생겼는데, 제가 입사하기 전에는 마샬링으로 처리 되어있었습니다. 하지만 교수님들이 데이터 시뮬레이션한 동역학 코드는 C++ 였기 때문에, 유지보수 측면, 책임 문제, 속도 문제등을 전반적으로 고려했을때 해당 코드를 DLL로 포팅하여서 유니티 시뮬레이션에 이식하였습니다.</p>

<p><feedback_h5>AI 훈수:</feedback_h5> 경험을 좀더 구체화 시켜라 </p>

- 유지보수 측면에서 어떤 이점이 있었는지 나타내줘라

추가: 이를 DLL로 포팅하고 그래픽으로 보여줄수 있는 간단한 툴을 만들어서 제공함으로서 보다 심도 있는 동역학-제어 실험환경을 조성하였습니다.

<br>

### <feedback_h3>8) 3D 엔진 기술에 대한 높은 이해가 중요한 이유는 무엇이며, 그동안 어떤 방식으로 3D 엔진에 대한 지식을 쌓아 왔는지 설명해 주세요.</feedback_h3>

<p><feedback_h5>다시 작성한 답:</feedback_h5> 3D 엔진은 기술에 대한 높은 이유가 중요한 이유는, 그것이 게임이 됬었던 시뮬레이션이 되었던 사용자에게 보다 좋은 경험들을 제공해 주기 위해서 입니다. 

예를들어 보다 쾌적한 환경을 제공해 주기 위해서는 LOD, GPU 인스턴싱 , 멀티 쓰레드 , 늦은 로딩등 같은 최적화 기술들이 필요하며 사실적인 경험을 제공해주기 위해선 조명 처리, HDC 톤매핑등이 필요합니다. 이처럼 저는 최근 블로그를 작성하면 유니티 최신 기술들을 분석하고 공부했습니다. 

앞으로 보다 사용자들에게 좋은 경험을 제공하기 위해서 노력하겠습니다. 감사합니다.</p>

<p><feedback_h5>AI 훈수:</feedback_h5> 3D 엔진 기술의 중요성 명확히 설명하기, 마무리 멘트 다듬기 </p>

**3D 엔진에 대한 높은 이해가 중요한 이유는, 그것이 게임이든 시뮬레이션이든 사용자에게 더 나은 경험을 제공하기 위해서입니다.**

<p>3D 엔진은 실시간으로 그래픽을 렌더링하고 다양한 물리적, 시각적 효과를 구현하기 때문에, 엔진의 기술적 이해가 부족하면 퍼포먼스 문제나 비현실적인 그래픽으로 인해 사용자 경험이 크게 저하될 수 있습니다.

예를 들어, 쾌적한 사용자 환경을 제공하려면 LOD(Level of Detail)와 같은 기술을 통해 멀리 있는 객체의 디테일을 줄이거나, GPU 인스턴싱을 통해 다수의 객체를 효율적으로 렌더링하고, 멀티 스레드로 작업을 분산시켜 성능을 최적화하는 것이 중요합니다. 또한, 사실적인 경험을 위해서는 조명 처리 기술이나 HDR(HDR 톤매핑)을 사용해 고품질의 그래픽을 구현해야 합니다.

저는 최근 블로그를 통해 유니티의 최신 기술에 대해 연구하고 분석하는 작업을 해왔습니다. 예를 들어, 유니티의 새로운 그래픽 파이프라인이나 최적화 기법에 대해 글을 쓰며, 관련 기술을 직접 적용해보는 경험을 쌓았습니다. 이를 통해 3D 엔진의 구조와 작동 방식, 그리고 다양한 최적화 기법에 대한 이해를 높일 수 있었습니다.

앞으로도 이러한 학습과 연구를 지속하며, 보다 나은 사용자 경험을 제공하기 위해 노력하겠습니다. 감사합니다.</p>